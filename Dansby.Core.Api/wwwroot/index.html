<!-- index.html -->
<!-- LAN-hosted test console for Dansby routing & replies -->

<!doctype html>
<meta charset="utf-8">
<title>Dansby Console</title>
<style>
  body { font-family: system-ui; margin: 2rem; max-width: 720px }
  pre { background: #111; color: #eee; padding: 1rem; border-radius: 8px; white-space: pre-wrap }
  .row { display: flex; gap: .5rem; flex-wrap: wrap; margin-top: .5rem }
  .row > * { flex: 1 0 auto }
  .reply { padding:.75rem 1rem; border:1px solid #ddd; border-radius:8px; background:#f9f9f9; margin:.5rem 0 }
  .muted { opacity:.7; font-size:.9em }
</style>

<h1>Dansby V2.0.0 Console</h1>

<input id = "apiKey" placeholder = "X-Api-Key" style = "width:100%"><br><br>

<!-- NEW: CSV file picker + helpers -->
<div class="row">
  <input id="csvFile" type="file" accept=".csv,text/csv" />
  <button id="loadCsv">Load CSV Into JSON</button>
  <button id="clearText">Clear</button>
</div>

<textarea id = "text" rows = "14" style = "width:100%"></textarea>

<div class = "row">
  <button id = "rec">Recognize</button>
  <button id = "route">Route</button>
  <button id = "respond">Respond</button>
  <button id = "debugHandle">Debug Handle</button>
</div>

<!-- NEW: quick toggles for printing -->
<div class="row">
  <button id="setPreview">Set Preview (doPrint:false)</button>
  <button id="setPrint">Set Print (doPrint:true)</button>
</div>

<div id = "prettyReply" class = "reply" style = "display:none"></div>
<div class = "muted" id = "rawLabel" style = "display:none">Raw response</div>
<pre id = "out"></pre>

<script>
  const el = id => document.getElementById(id);
  const val = id => el(id).value.trim();

  // Best-effort extractor for a "reply" or "message" from various shapes.
  function extractReply(obj) 
  {
    if (!obj || typeof obj !== 'object') return '';

    // Common shapes to try, in order:
    // 1) { reply: "..." } or { text: "..." }
    if (typeof obj.reply === 'string') return obj.reply;
    if (typeof obj.text === 'string') return obj.text;
    if (typeof obj.message === 'string') return obj.message;

    // 2) envelope-ish: { result: { reply/text/... } }
    if (obj.result) 
    {
      const r = extractReply(obj.result);
      if (r) return r;
    }

    // 3) pipelines/handlers: { outputs: [{ text: ... }]} or { messages: [{ text: ... }]}
    const arrays = ['outputs','messages','items','steps'];
    for (const key of arrays) 
    {
      if (Array.isArray(obj[key])) 
      {
        for (const item of obj[key]) 
        {
          const r = extractReply(item);
          if (r) return r;
        }
      }
    }

    // 4) nested payloads: { data: {...} } / { payload: {...} }
    if (obj.data) 
    {
      const r = extractReply(obj.data);
      if (r) return r;
    }
    if (obj.payload) 
    {
      const r = extractReply(obj.payload);
      if (r) return r;
    }

    // 5) content-like: { content: "..." } or { content: [{ text: "..." }] }
    if (typeof obj.content === 'string') return obj.content;
    if (Array.isArray(obj.content)) 
    {
      for (const c of obj.content) 
      {
        const r = extractReply(c);
        if (r) return r;
      }
    }

    return '';
  }

  function showRaw(text) 
  {
    el('out').textContent = text;
    el('rawLabel').style.display = text ? '' : 'none';
  }

  function showReply(reply) 
  {
    const box = el('prettyReply');
    if (reply) 
    {
      box.textContent = reply;
      box.style.display = '';
    } else 
    {
      box.style.display = 'none';
      box.textContent = '';
    }
  }

  async function post(url, body) 
  {
    showReply('');
    showRaw(''); // clear
    try 
    {
      const r = await fetch(url, 
      {
        method: 'POST',
        headers: 
        {
          'Content-Type': 'application/json',
          'X-Api-Key': val('apiKey')
        },
        body: JSON.stringify(body)
      });

      const text = await r.text();

      // Try JSON first
      try 
      {
        const json = JSON.parse(text);
        const reply = extractReply(json);
        if (reply) showReply(reply);
        showRaw(JSON.stringify(json, null, 2));
      } catch 
      {
        // Not JSON â€” just show as text
        showRaw(text || '(empty response)');
      }
    } catch (e) 
    {
      showReply('');
      showRaw('Request failed: ' + (e?.message || e));
    }
  }

  // NEW: Build a default zebra mailer JSON envelope from csvText
  function buildMailerJson(csvText, doPrint)
  {
    return {
      intent: "zebra.print.mailer.csv",
      payload: {
        csvText: csvText,
        hasHeader: true,
        printReturnLabel: true,
        splitReturnToSeparateLabel: false,
        maxLabels: 999,
        doPrint: !!doPrint
      }
    };
  }

  // NEW: Try to update doPrint in current JSON text (best-effort)
  function setDoPrintFlag(flag)
  {
    let obj;
    try 
    {
      obj = JSON.parse(el('text').value);
    } catch 
    {
      showRaw("JSON parse failed. Load CSV into JSON first (or paste valid JSON).");
      return;
    }

    if (!obj || typeof obj !== "object")
      return;

    if (!obj.payload || typeof obj.payload !== "object")
      obj.payload = {};

    obj.payload.doPrint = !!flag;
    el('text').value = JSON.stringify(obj, null, 2);
  }

  // NEW: Read CSV file and load JSON into textarea
  async function loadCsvToJson()
  {
    const file = el('csvFile').files?.[0];
    if (!file)
    {
      showRaw("Pick a .csv file first.");
      return;
    }

    const csvText = await file.text();

    // Default: preview mode
    const obj = buildMailerJson(csvText, false);
    el('text').value = JSON.stringify(obj, null, 2);
    showRaw("CSV loaded into JSON. Click Debug Handle to preview. Use Set Print to switch doPrint=true.");
  }

  // NEW: Buttons for csv utilities
  el('loadCsv').onclick = () => loadCsvToJson();
  el('clearText').onclick = () => { el('text').value = ""; showReply(""); showRaw(""); };

  el('setPreview').onclick = () => setDoPrintFlag(false);
  el('setPrint').onclick   = () => setDoPrintFlag(true);

  // Debug Handle button posts the JSON envelope directly to /debug/handle
  el('debugHandle').onclick = () => 
  {
    let obj;
    try 
    {
      obj = JSON.parse(el('text').value);
    } catch (e) 
    {
      showRaw("Invalid JSON: " + e.message);
      return;
    }
    post('/debug/handle', obj);
  };

  // Buttons
  el('rec').onclick   = () => post('/debug/recognize', { text: val('text') });

  // Your existing route (fire the router; shows raw response)
  el('route').onclick = () => post('/intents', { intent: 'nlp.route', payload: { text: val('text') } });

  // Respond (extract a human-friendly reply)
  el('respond').onclick = () => post('/debug/respond', { text: val('text') });
</script>
